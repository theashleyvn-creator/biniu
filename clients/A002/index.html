<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>The Ashley ¬∑ 3D messages (offline, fixed)</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #hud{position:fixed;left:12px;top:12px;z-index:20;display:flex;gap:8px;align-items:center}
  #toggle{background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.2);color:#fff;border-radius:10px;padding:8px 10px;font-size:13px}
  #panel{position:fixed;left:12px;top:48px;width:min(92vw,420px);background:rgba(12,12,12,.85);
         border:1px solid rgba(255,255,255,.16);backdrop-filter:blur(8px);color:#eee;border-radius:14px;padding:10px;z-index:19;display:none}
  #panel label{display:block;font-size:12px;margin:6px 0 4px;color:#bbb}
  #panel textarea{width:100%;height:72px;border-radius:10px;border:1px solid rgba(255,255,255,.18);
                  background:#0b0b0b;color:#fff;padding:8px;font-size:13px;resize:vertical}
  #panel input{width:100%;border-radius:10px;border:1px solid rgba(255,255,255,.18);background:#0b0b0b;color:#fff;padding:8px;font-size:13px}
  #row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  #apply{margin-top:8px;width:100%;padding:10px;border-radius:12px;border:0;background:#6b8cff;color:#fff;font-weight:600}
  #info{position:fixed;right:10px;bottom:10px;color:#bbb;font-size:11px;z-index:10;opacity:.85}
</style>
</head>
<body>
<div id="hud"><button id="toggle">‚öôÔ∏è T√πy ch·ªânh</button></div>

<div id="panel">
  <label>N·ªôi dung (ngƒÉn c√°ch b·∫±ng <b>|</b>)</label>
  <textarea id="messages">Y√™u BINNN|20/10.2023|Ch√∫c m·ª´ng sinh nh·∫≠t|B√™n nhau nhi·ªÅu sinh nh·∫≠t nh√© üéÇüéÇ</textarea>
  <div id="row">
    <div>
      <label>S·ªë text (30‚Äì200)</label>
      <input id="ntext" type="number" min="30" max="200" value="120"/>
    </div>
    <div>
      <label>S·ªë tr√°i tim (20‚Äì300)</label>
      <input id="nheart" type="number" min="20" max="300" value="90"/>
    </div>
  </div>
  <label>M√†u ch·ªØ (HEX, ph·∫©y ,)</label>
  <input id="colors" value="FFFFFF,FF8AF5,E8D1FF,FFCCD5"/>
  <button id="apply">C·∫≠p nh·∫≠t</button>
</div>

<div id="info">The Ashley ¬∑ 3D messages (offline)</div>

<script>
/* ===== Mini engine (WebGL + controls) ‚Äì kh√¥ng c·∫ßn CDN ===== */
class Vec3{constructor(x=0,y=0,z=0){this.x=x;this.y=y;this.z=z}set(x,y,z){this.x=x;this.y=y;this.z=z;return this}add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;return this}multiplyScalar(s){this.x*=s;this.y*=s;this.z*=s;return this}length(){return Math.hypot(this.x,this.y,this.z)}clone(){return new Vec3(this.x,this.y,this.z)}}
const canvas=document.createElement('canvas');const gl=canvas.getContext('webgl',{antialias:true,alpha:false});
document.body.appendChild(canvas);
function resize(){const w=innerWidth,h=innerHeight; const px=Math.min(devicePixelRatio,2); canvas.width=Math.floor(w*px); canvas.height=Math.floor(h*px); canvas.style.width=w+'px'; canvas.style.height=h+'px';}
resize(); addEventListener('resize',resize,{passive:true});

function perspective(out,fovy,aspect,near,far){const f=1/Math.tan(fovy/2);out[0]=f/aspect;out[1]=0;out[2]=0;out[3]=0;out[4]=0;out[5]=f;out[6]=0;out[7]=0;out[8]=0;out[9]=0;out[10]=(far+near)/(near-far);out[11]=-1;out[12]=0;out[13]=0;out[14]=(2*far*near)/(near-far);out[15]=0;return out}
function lookAt(out,eye,center,up){let x0,x1,x2,y0,y1,y2,z0,z1,z2;z0=eye.x-center.x;z1=eye.y-center.y;z2=eye.z-center.z;let len=Math.hypot(z0,z1,z2)||1;z0/=len;z1/=len;z2/=len;x0=up.y*z2-up.z*z1;x1=up.z*z0-up.x*z2;x2=up.x*z1-up.y*z0;len=Math.hypot(x0,x1,x2)||1;x0/=len;x1/=len;x2/=len;y0=z1*x2-z2*x1;y1=z2*x0-z0*x2;y2=z0*x1-z1*x0;out[0]=x0;out[1]=y0;out[2]=z0;out[3]=0;out[4]=x1;out[5]=y1;out[6]=z1;out[7]=0;out[8]=x2;out[9]=y2;out[10]=z2;out[11]=0;out[12]=-(x0*eye.x+x1*eye.y+x2*eye.z);out[13]=-(y0*eye.x+y1*eye.y+y2*eye.z);out[14]=-(z0*eye.x+z1*eye.y+z2*eye.z);out[15]=1;return out}

const VSH=`
attribute vec3 position; attribute vec2 uv;
uniform mat4 uProj,uView,uModel;
varying vec2 vUV;
void main(){ vUV=uv; gl_Position=uProj*uView*uModel*vec4(position,1.0); }
`;
const FSH=`
precision mediump float;
varying vec2 vUV;
uniform sampler2D map;
uniform float opacity;
void main(){
  // l·∫≠t UV theo tr·ª•c Y ƒë·ªÉ kh√¥ng b·ªã ng∆∞·ª£c
  vec2 uv = vec2(vUV.x, 1.0 - vUV.y);
  vec4 c = texture2D(map, uv);
  gl_FragColor = vec4(c.rgb, c.a * opacity);
}
`;
function shader(type,src){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))throw gl.getShaderInfoLog(s);return s}
function program(vs,fs){const p=gl.createProgram();gl.attachShader(p,shader(gl.VERTEX_SHADER,vs));gl.attachShader(p,shader(gl.FRAGMENT_SHADER,fs));gl.linkProgram(p);if(!gl.getProgramParameter(p,gl.LINK_STATUS))throw gl.getProgramInfoLog(p);return p}
const PROG=program(VSH,FSH); gl.useProgram(PROG);

const quad=new Float32Array([ -1,-1,0, 0,0,  1,-1,0, 1,0,  -1,1,0, 0,1,  1,1,0, 1,1 ]);
const vbo=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,vbo); gl.bufferData(gl.ARRAY_BUFFER,quad,gl.STATIC_DRAW);
const aPos=gl.getAttribLocation(PROG,'position'), aUV=gl.getAttribLocation(PROG,'uv');
gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,20,0);
gl.enableVertexAttribArray(aUV);  gl.vertexAttribPointer(aUV,2,gl.FLOAT,false,20,12);
const uProj=gl.getUniformLocation(PROG,'uProj'), uView=gl.getUniformLocation(PROG,'uView'), uModel=gl.getUniformLocation(PROG,'uModel'), uMap=gl.getUniformLocation(PROG,'map'), uOpacity=gl.getUniformLocation(PROG,'opacity');
gl.uniform1i(uMap,0);

const PROJ=new Float32Array(16), VIEW=new Float32Array(16);
let camTarget=new Vec3(0,0,0); let dist=90, minD=20, maxD=260; let rotX=0, rotY=0;
function updateView(){lookAt(VIEW,new Vec3(camTarget.x+dist*Math.cos(rotY)*Math.cos(rotX),camTarget.y+dist*Math.sin(rotY),camTarget.z+dist*Math.cos(rotY)*Math.sin(rotX)),camTarget,new Vec3(0,1,0)); perspective(PROJ,65*Math.PI/180,canvas.width/canvas.height,0.1,1000); gl.uniformMatrix4fv(uProj,false,PROJ); gl.uniformMatrix4fv(uView,false,VIEW)}
updateView();

/* Controls */
let dragging=false,lx=0,ly=0,touches=[];
canvas.addEventListener('mousedown',e=>{dragging=true;lx=e.clientX;ly=e.clientY;});
addEventListener('mouseup',()=>dragging=false);
addEventListener('mousemove',e=>{if(!dragging)return; const dx=e.clientX-lx,dy=e.clientY-ly; rotX+=dx*0.005; rotY+=-dy*0.005; rotY=Math.max(-1.55,Math.min(1.55,rotY)); lx=e.clientX; ly=e.clientY; updateView();});
canvas.addEventListener('wheel',e=>{dist*=(1+Math.sign(e.deltaY)*0.08); dist=Math.max(minD,Math.min(maxD,dist)); updateView();},{passive:true});
canvas.addEventListener('touchstart',e=>{touches=[...e.touches]; if(touches.length===1){lx=touches[0].clientX;ly=touches[0].clientY;}},{passive:true});
canvas.addEventListener('touchmove',e=>{
  if(e.touches.length===1 && touches.length===1){
    const t=e.touches[0]; const dx=t.clientX-lx,dy=t.clientY-ly;
    rotX+=dx*0.005; rotY+=-dy*0.005; rotY=Math.max(-1.55,Math.min(1.55,rotY)); lx=t.clientX; ly=t.clientY; updateView();
  }else if(e.touches.length===2){
    const d=(a,b)=>Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY);
    const prev=d(touches[0],touches[1]); const now=d(e.touches[0],e.touches[1]);
    if(prev&&now){ const k=prev/now; dist*=k; dist=Math.max(minD,Math.min(maxD,dist)); updateView(); }
    touches=[...e.touches];
  }
},{passive:true});

/* ===== Textures ===== */
function nextPow2(n){let p=1;while(p<n)p<<=1;return p;}
function makeTexture(draw,sizeW,sizeH,useMipmap=true){
  const c=document.createElement('canvas'); c.width=sizeW; c.height=sizeH;
  const ctx=c.getContext('2d'); draw(ctx,sizeW,sizeH);
  const tex=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,tex);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,c);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
  if(useMipmap){ gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR_MIPMAP_LINEAR); gl.generateMipmap(gl.TEXTURE_2D); }
  else{ gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR); }
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
  return tex;
}
function neonTextTexture(str,color="#ffffff"){
  const tmp=document.createElement('canvas'); const m=tmp.getContext('2d');
  let fontSize=96; const pad=28; m.font=`${fontSize}px Arial, Helvetica, sans-serif`;
  let w=m.measureText(str).width;
  const MAX=1024;
  if(w+2*pad>MAX){const ratio=(MAX-2*pad)/w; fontSize=Math.max(32,Math.floor(fontSize*ratio)); m.font=`${fontSize}px Arial, Helvetica, sans-serif`; w=m.measureText(str).width;}
  const cw=nextPow2(Math.min(MAX,Math.ceil(w+2*pad)));
  const ch=nextPow2(Math.min(MAX,Math.ceil(fontSize+2*pad)));
  const aspect=cw/ch;
  const tex=makeTexture((ctx,W,H)=>{
    ctx.clearRect(0,0,W,H);
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.font=`${fontSize}px Arial, Helvetica, sans-serif`;
    ctx.shadowColor=color; ctx.shadowBlur=Math.floor(H*0.10);
    ctx.fillStyle=color; ctx.fillText(str,W/2,H/2);
  }, cw, ch, true);
  return {tex, aspect};
}
function heartTexture(color="#ff5a5f"){
  const S=256;
  return makeTexture((ctx,W,H)=>{
    ctx.clearRect(0,0,W,H); ctx.fillStyle=color; ctx.shadowColor=color; ctx.shadowBlur=S*0.08;
    const w=W,h=H,x=w/2,y=h*0.38,r=w*0.18;
    ctx.beginPath(); ctx.moveTo(x,y);
    ctx.bezierCurveTo(x+r,y-r,x+0.5*w,y+0.1*h,x,y+0.52*h);
    ctx.bezierCurveTo(x-0.5*w,y+0.1*h,x-r,y-r,x,y);
    ctx.fill();
  }, S, S, true);
}
const heartTex=heartTexture();

/* ===== Scene data ===== */
const texts=[], hearts=[], stars=[];
function randInSphere(R=80){const r=R*Math.cbrt(Math.random()); const u=Math.random(),v=Math.random(); const th=2*Math.PI*u, ph=Math.acos(2*v-1); return new Vec3(r*Math.sin(ph)*Math.cos(th), r*Math.sin(ph)*Math.sin(th), r*Math.cos(ph));}
(function(){for(let i=0;i<2000;i++){stars.push({pos:randInSphere(420), size:0.6+Math.random()*1.2, opacity:0.35});}})();
function colorHexToCss(i){return '#'+i.toString(16).padStart(6,'0').toUpperCase()}

/* Billboard draw (ƒë√∫ng ma tr·∫≠n, c√≥ aspect) */
function drawSprite(tex,pos,size,opacity,aspect=1){
  gl.uniform1f(uOpacity, opacity);
  // transpose rotation c·ªßa VIEW => m·∫∑t ph·∫≥ng lu√¥n nh√¨n camera
  const m=new Float32Array(16);
  m[0]=VIEW[0];  m[1]=VIEW[4];  m[2]=VIEW[8];  m[3]=0;
  m[4]=VIEW[1];  m[5]=VIEW[5];  m[6]=VIEW[9];  m[7]=0;
  m[8]=VIEW[2];  m[9]=VIEW[6];  m[10]=VIEW[10];m[11]=0;
  m[12]=pos.x;   m[13]=pos.y;   m[14]=pos.z;   m[15]=1;
  const sx=size*aspect, sy=size;
  m[0]*=sx; m[1]*=sx; m[2]*=sx;
  m[4]*=sy; m[5]*=sy; m[6]*=sy;
  gl.uniformMatrix4fv(uModel,false,m);
  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D,tex);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
}

/* Populate */
function parseColors(str){return str.split(',').map(s=>parseInt('0x'+(s.replace('#','').trim()||'FFFFFF')));}
function populate({messages,colors,nText,nHeart}){
  texts.length=0; hearts.length=0;
  const cache=new Map();
  const getTex=(msg,col)=>{const k=msg+'_'+col; if(cache.has(k)) return cache.get(k); const t=neonTextTexture(msg,colorHexToCss(col)); cache.set(k,t); return t;};
  for(let i=0;i<nText;i++){
    const msg=messages[i%messages.length], col=colors[i%colors.length];
    const info=getTex(msg,col);
    texts.push({pos:randInSphere(80), vel:new Vec3((Math.random()-.5)*.04,(Math.random()-.5)*.04,(Math.random()-.5)*.04), size:3+Math.random()*1.2, tex:info.tex, aspect:info.aspect, opacity:.95});
  }
  for(let i=0;i<nHeart;i++){
    hearts.push({pos:randInSphere(85), vel:new Vec3((Math.random()-.5)*.06,(Math.random()-.5)*.06,(Math.random()-.5)*.06), size:1.6+Math.random()*1.8, tex:heartTex, opacity:.9});
  }
}

/* UI */
const $=id=>document.getElementById(id);
const $toggle=$('toggle'),$panel=$('panel'),$messages=$('messages'),$ntext=$('ntext'),$nheart=$('nheart'),$colors=$('colors'),$apply=$('apply');
$toggle.onclick=()=>{$panel.style.display=($panel.style.display==='none'||!$panel.style.display)?'block':'none';};
function getOpts(){const msgs=$messages.value.split('|').map(s=>s.trim()).filter(Boolean); let nt=+($ntext.value||120); nt=Math.min(200,Math.max(30,nt)); let nh=+($nheart.value||90); nh=Math.min(300,Math.max(20,nh)); const cols=parseColors($colors.value); return {messages:msgs.length?msgs:['Y√™u anh'],colors:cols.length?cols:[0xffffff],nText:nt,nHeart:nh};}
populate(getOpts()); $apply.onclick=()=>populate(getOpts());

/* Render loop */
gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
const clockStart=performance.now();
function loop(){
  requestAnimationFrame(loop);
  // auto-rotate nh·∫π
  const t=(performance.now()-clockStart)/1000;
  rotX += 0.002; updateView();

  gl.viewport(0,0,canvas.width,canvas.height);
  gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT);

  // sao (t·∫≠n d·ª•ng heartTex l√†m ch·∫•m ph√°t s√°ng nh·ªè ƒë·ªÉ ti·∫øt ki·ªám code)
  stars.forEach(s=>drawSprite(heartTex,s.pos,s.size*0.2,s.opacity,1));

  // drift + v·∫Ω
  texts.forEach(o=>{o.pos.add(o.vel); if(o.pos.length()>90)o.vel.multiplyScalar(-1); drawSprite(o.tex,o.pos,o.size,o.opacity,o.aspect);});
  hearts.forEach(o=>{o.pos.add(o.vel); if(o.pos.length()>95)o.vel.multiplyScalar(-1); drawSprite(o.tex,o.pos,o.size,o.opacity,1);});
}
loop();
</script>
</body>
</html>
